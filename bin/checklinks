#!/usr/bin/env perl
use strict;
use warnings;
use Term::ANSIColor;

my $base = $ENV{HOME};
my ($type, $src, $dst);
my $quiet = 0;

unless (-f ".links") {
	exit 0;
}

if (defined($ARGV[0]) and $ARGV[0] eq '-q') {
	$quiet = 1;
}

open(LINKS, '<.links') or die($!);
while(<LINKS>) {
	chomp;
	($type, $src, $dst) = split;
	if ($type eq 'soft') {
		check_symlink($src, $dst);
	} elsif ($type eq 'hard') {
		check_hardlink($src, $dst);
	}
}
close(LINKS);

sub check_symlink {
	my $src = shift;
	my $dst = shift;

	#if (not -e "$base/$dst") {
	#	print_format('no dst!!', $src, $dst, 'red bold');
	#}
	if (not -l "$base/$src" and not -e "$base/$src") {
		symlink($dst, "$base/$src");
		print_format('created', $src, $dst, 'cyan');
	}
	elsif (readlink("$base/$src") eq $dst) {
		print_format('ok', $src, $dst, 'green') unless ($quiet);
	}
	elsif (readlink("$base/$src") eq "$base/$dst") {
		print_format('absolute', $src, $dst, 'yellow') unless ($quiet);
	}
	elsif (not -l "$base/$src" and -e "$base/$src") {
		print colored ("$base/$src: File exists but is not a symlink. Not updating.\n", 'bold red');
	}
	elsif (-l "$base/$src") {
		unlink("$base/$src");
		symlink($dst, "$base/$src");
		print_format('fixed', $src, $dst, 'cyan');
	}
}

sub check_hardlink {
	my $src = shift;
	my $dst = shift;

	if (not -e "$base/$dst") {
		print_format('no dst!!', $src, $dst, 'red bold');
	}
	elsif (not -f "$base/$src") {
		link("$base/$dst", "$base/$src") or warn($!);
		print_format('created', $src, $dst, 'cyan');
	}
	elsif ((stat("$base/$src"))[1] != (stat("$base/$dst"))[1]) {
		unlink("$base/$src");
		link("$base/$dst", "$base/$src") or warn($!);
		print_format('updated', $src, $dst, 'cyan');
	}
	elsif ((stat("$base/$src"))[1] == (stat("$base/$dst"))[1]) {
		print_format('ok', $src, $dst, 'green') unless ($quiet);
	}
}

sub print_format {
	my ($message, $src, $dst, $color) = @_;

	$message .= ' 'x(9-length($message));
	$src .= ' 'x(15-length($src));
	$dst .= ' 'x(15-length($dst));
	if (defined($color)) {
		print colored ($message, $color);
	} else {
		print $message;
	}
	print "$src -> $dst\n";
}

__END__

=head1 NAME

checklinks - create/update symlinks

=head1 SYNOPSIS

B<checklinks> [ B<-q> ]

=head1 DESCRIPTION

Create or update symlinks based on a file

=head1 OPTIONS

=over

=item B<-q>

quiet. Hide unchanged symlinks

=back

=head1 FILES

The symlink definitions are read from the file F<.links> in the current working
directory. Each line contains, separated by spaces:

=over

=item the symlink type

This may be one of 'soft' or 'hard', indicating either a symlink or a hardlink.
Note: The use of hardlinks is discouraged and not documented. The following
definitions only apply to symlinks. For hardlinks, may the source be with you.

=item the source

path of the source, i.e. the symlink. Relative to $HOME

=item the target

path of the target, i.e. the symlink's destination.
This is relativ to the source. See L<path_resolution>(7)

=back

Lines beginning with an invalid symlink type will be ignored.

=head1 BUGS

There are no checks whether the symlink target actually exists
